/*
 * WiFi IP Camera Arduino program For ESP32-Cam (Free Revision)
 * Rev 1.1
 *
 * Tested with esp32 board 3.2.0 and Ai Thinker ESP32-Cam
 *
 * Video stream File
 *
 * Author: M. Mahdi K. Kanan (mvtdesign@gmail.com)
 * WiCardTech Engineering Group (https://wicard.net)
 *
 * All of the revisions:
 * ESP32 WiFi Microphone (12bit@8KHz - Free Revision) --> https://wicard.net/projects/Arduino/ESP32-ESP8266/ESP32%20WiFi%20Microphone%20free%20arduino%20source%20code
 * ESP8266 WiFi Microphone (10bit@8KHz - Free Revision) --> https://wicard.net/projects/Arduino/ESP32-ESP8266/ESP8266%20WiFi%20Microphone%20free%20arduino%20source%20code
 * ESP32 WiFi Microphone and Recorder --> https://wicard.net/projects/Arduino/ESP32-ESP8266/esp32-voice-recorder
 * ESP8266 WiFi Microphone and Recorder --> https://wicard.net/projects/Arduino/ESP32-ESP8266/nodemcu-voice-recorder-esp8266
 * ESP32-Cam IP-Camera (Free Revision) --> https://wicard.net/projects/Arduino/ESP32-ESP8266/esp32cam-ipcamera-bin
 * ESP32-Cam HD DashCam --> https://wicard.net/projects/Arduino/ESP32-ESP8266/esp32-cam-DashCam
 * ESP32-Cam CCTV --> https://wicard.net/projects/Arduino/ESP32-ESP8266/ESP32-CAM%20CCTV%20IP%20Camera
 * ESP32-Cam Camera and Microphone --> https://wicard.net/projects/Arduino/ESP32-ESP8266/spycam-video-audio-esp32cam
 *
*/

void capturePage()
{
  camera_fb_t * fb = NULL;
  
  capturing = CAPTURING_DELAY;
  
#ifdef LOG_ENABLE
    Serial.print("cap");
#endif

  fb = esp_camera_fb_get();
  
  if (!fb)
  {
#ifdef LOG_ENABLE
    Serial.println("Camera capture failed");
#endif

    const char _err_buf[374] = {0x42,0x4D,0x76,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x36,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x01,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x40,0x01,0x00,0x00,0xC4,0x0E,0x00,0x00,0xC4,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x24,0x1C,0xED,0x24,0x1C,0xED,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x24,0x1C,0xED,0x24,0x1C,0xED,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x24,0x1C,0xED,0x24,0x1C,0xED,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x24,0x1C,0xED,0x24,0x1C,0xED,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x24,0x1C,0xED,0x24,0x1C,0xED,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x24,0x1C,0xED,0x24,0x1C,0xED,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x24,0x1C,0xED,0x24,0x1C,0xED,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x24,0x1C,0xED,0x24,0x1C,0xED,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00};

    Server.send_P(200, "image/bmp", _err_buf, 374);

    digitalWrite(33, LOW);
  }
  else
  {
    int i;
    
    if(bVidRec && PicNumber != 0 && capturingFrame != 0)
    {
      if(capturingFrame == ucVidTime)
      {
        digitalWrite(33, LOW);
        
        generatePicName();

        jpegFileName[8] = '4';
        
#ifdef OLD_MEMORY_CARD
        myFile = SD_MMC.open((const char *)jpegFileName, FILE_WRITE);
#else
        myFile = SD.open((const char *)jpegFileName, FILE_WRITE);
#endif

        i = 0;
      }
      else
      {
#ifdef OLD_MEMORY_CARD
        myFile = SD_MMC.open((const char *)jpegFileName, FILE_WRITE);
#else
        myFile = SD.open((const char *)jpegFileName, FILE_WRITE);
#endif
      
        i = myFile.size();
      }
      
      unsigned char len[4];
      
      myFile.seek(i);
      len[0] = fb->len & 0xFF;
      len[1] = (fb->len >> 8) & 0xFF;
      len[2] = (fb->len >> 16) & 0xFF;
      len[3] = (fb->len >> 32) & 0xFF;
      myFile.write(len, 4);
      myFile.write(fb->buf, fb->len);
      myFile.close();

      capturingFrame--;
  
      /*if(bPinMode == false)
      {
        pinMode(4, OUTPUT);
        digitalWrite(4, HIGH);
      }*/
      
      if(capturingFrame == 0)
        digitalWrite(33, HIGH);
    }
    
    if(currentFrame == 0)
    {
      for(i = 0; i < fb->len; i++)//= CAP_DIFF_ACCURACY)
        currentFrame += fb->buf[i];
  
      if(lastFrame == 0)
        lastFrame = currentFrame;
    }

    if(bVidRec && PicNumber != 0 && capturingFrame == 0)
    {
      i = (currentFrame * CAP_DIFF_ACCURACY) / (currentFrame + lastFrame);
      
      if(i > (50+ucVidMotion) || i < (50-ucVidMotion))
        capturingFrame = ucVidTime;
        
      lastFrame = currentFrame;
      currentFrame = 0;
    }

    Server.send_P(200, "image/jpeg", (const char *)fb->buf, fb->len);
    delay(1);
    
#ifdef LOG_ENABLE
    Serial.print("tu");
#endif
  }
  esp_camera_fb_return(fb);
#ifdef LOG_ENABLE
    Serial.println("red");
#endif
  //free(fb);
  //fb = NULL;
}

void capture()
{
  camera_fb_t * fb = NULL;

#ifdef LOG_ENABLE
    Serial.print("cap");
#endif

  fb = esp_camera_fb_get();
  
  if (!fb)
  {
#ifdef LOG_ENABLE
    Serial.println("Camera capture failed");
#endif
    digitalWrite(33, LOW);
  }
  else
  {
    int i;

#ifdef LOG_ENABLE
    Serial.print("tu");
#endif

    if(capturingFrame)
    {
      if(capturingFrame == ucVidTime)
      {
        digitalWrite(33, LOW);
        
        generatePicName();

        jpegFileName[8] = '4';
        
#ifdef OLD_MEMORY_CARD
        myFile = SD_MMC.open((const char *)jpegFileName, FILE_WRITE);
#else
        myFile = SD.open((const char *)jpegFileName, FILE_WRITE);
#endif
        
        i = 0;
      }
      else
      {
#ifdef OLD_MEMORY_CARD
        myFile = SD_MMC.open((const char *)jpegFileName, FILE_WRITE);
#else
        myFile = SD.open((const char *)jpegFileName, FILE_WRITE);
#endif
      
        i = myFile.size();
      }
      
      unsigned char len[4];

      myFile.seek(i);
      len[0] = fb->len & 0xFF;
      len[1] = (fb->len >> 8) & 0xFF;
      len[2] = (fb->len >> 16) & 0xFF;
      len[3] = (fb->len >> 32) & 0xFF;
      //myFile.seek(i+4);
      myFile.write(len, 4);
      myFile.write(fb->buf, fb->len);
      myFile.close();

      capturingFrame--;
  
      /*if(bPinMode == false)
      {
        pinMode(4, OUTPUT);
        digitalWrite(4, HIGH);
      }*/
      
      if(capturingFrame == 0)
        digitalWrite(33, HIGH);
    }

    if(currentFrame == 0)
    {
      for(i = 0; i < fb->len; i++)//+= CAP_DIFF_ACCURACY
        currentFrame += fb->buf[i];
  
      if(lastFrame == 0)
        lastFrame = currentFrame;
    }
  }
  esp_camera_fb_return(fb);
  
#ifdef LOG_ENABLE
    Serial.println("red");
#endif
  //free(fb);
  //fb = NULL;
}
